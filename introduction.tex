\chapter{Uvod}

Sve je bitnije proizvesti bolji i kvalitetniji softver. Svaki korisnik želi što bolju moguću aplikaciju, iako je definicja \textit{"što je bolje"} drugačija za svakog pojedinca, nerijetko uključuje efikasnost kao jedan od glavnih parametara. Uz sve napore struke činjenica je ta da je softver sve manje efikasan iako, prema \textit{Moore}ovom zakonu\engl{Moore's Law}\cite{mooresLaw}, bi trebalo biti baš obrnuto. \textit{Moore}-ov zakon govori o tome kako se broj tranzistora u integriranim krugovima\engl{Integrated Circuits, IC} udvostručava svake dvije godine. Iz toga bi bilo logično zaključiti kako sami integrirani krugovi postaju efikasniji i time da i programi izvršavani na njima bivaju također efikasniji. Na žalost, nije tako jednostavno, u stvarnosti ispada da iako hardver postaje efikasniji, softver je sve manje efikasan. O tome govori, tzv., \textit{Wirth}-ov zakon, koji govori kako brzina software pada više no što brzina hardvera raste. \textit{Wirth}-ov zakon:
\begin{quote}
    ``Software is getting slower more rapidly than hardware is getting faster.''\cite{wirthsLaw}
\end{quote}
Dodatno, ne govori samo o brzini softvera već i o njegovoj kompleksnosti koja višestruko raste u usporedbi s kompleksnosti hardvera. Objašnjenje zašto se ovo događa leži u činjenici kako današnje aplikacije nude funkcionalnosti koje nisu striktno vezane za glavnu funkcionalnost prvotne aplikacije. Tako na primjer, danas će mnogi uređivači teksta zahtjevati internetsku vezu iako sama primarna funkcionalnost uređivanja teksta nema potrebu za internetskom vezom. Ovo je tipičan primjer gdje aplikacija nudi dodatne funkcionalnosti koje imaju dodatne ovisnosti, konkretno u primjeru internetsku vezu, i time uvode dodatnu kompleksnost u izradu samog proizvoda na benefit korisnika koji dobiva više mogućnosti. Samim uvođenjem dodatnih mogućnosti krajnji proizvod postaje memorijski, a vrlo često i procesivno zahtjevniji. \\ 

Dodatna i možda bitnija činjenica zašto softver postaje sve kompleksniji je obilje, često specijaliziranog, hardvera dostupnog za korištenje unutar aplikacija. Poznato je kako smo pred krajem \textit{Moore}-ova zakona, odnosno činjenicom da se tranzistori više neće moći fizički smanjiti kako bi se mogao udvostručiti broj tranzistora na jednom integriranom krugu. Buduća ubrzanja su jedino moguća tako da se posao raspodijeli na više procesora, odnosno, došli smo do samih limita što je moguće ostvariti na jednom procesoru. Samim time logično je očekivati samo još više specijaliziranih IC-ova unutar budućih platformi kako bi se koristili za izradu aplikacija. Direktna je implikacija da će softver time biti još kompleksniji, što je i za očekivati po \textit{Wirth}-ovom zakonu. \\ 

Pitanje je \textit{"Kako se boriti sa kompleksnošću?"}, \textit{"Da li je moguće potpuno elimirati kompleksnost?"}. Na žalost, iskustva pokazuju da je kompleksnost nužna, odnosno moderan softver zahtjeva kompleksna rješenja. Međutim, struka je razvila alate koji mogu pomoći oko kompleksnosti. Do sada vjerojatno najbolji alat za suzbijanje komplesknosti mora biti \textbf{apstrakcija}\engl{Abstraction}. Iako se pojam abstrakcije gotovo uvijek spominje u kontesktu Objektno orjentiranog programiranja\engl{Object Oriented Programing, OOP}, sami koncept nije nužno vezan samo za OOP, međutim nedvojbeno je da koncept ima svoje začetke u Objektno orjentiranoj paradigmi\engl{Object oriented paradigm}. Apstrakcija je proces izgradnje jednostavnijeg modela kompleksnih jedinica tako da sadrži dovoljno informacije za ispunjenje zadatka u određenom kontekstu. \\   

Od dva navedena razloga koja objašnjavaju zašto \textit{Writh}-ov zakon vrijedi, prvi se za konektst ovog diplomskog rada može zanemariti i protumačiti kao tzv. \textit{Code Bloat}, odnosno kompleksnost koja je uvedena zbog dodavanja "nepotrebnog" koda. Drugi razlog je mnogo interesantniji i intrigantniji jer se radi o problemu tehničke naravi, ključnim za ovaj diplomksi rad. Kako je predhodno rečeno razlog povećanja kompleksnosti softvera je dodavanje specijaliziranog hardvera za kojeg je najčešće potrebno izgraditi upravljački program za jednostavniju uporabu uređaja. Konkretno ovaj diplomski rad promatra kako se nositi sa kompleksnosti i izazovima izrade upravljačkih programa za moderne aplikacije na ugradbenim uređajima. Činjenica o tome da softver generalno postaje kompleksniji je možda najviše vidljiva upravo u domeni ugradbenih uređaja, pogotvo tamo gdje se pokušava izgraditi generično riješenje. Moderan softver u domeni ugradbenih uređaja nužno zahtjeva modernije tehnologije nego što je trenutna praksa kako bi se sama domena programske potpore za ugradbene uređaje nastavila razvijati.
\pagebreak

\section{Što je ugradbeni uređaj?}
Definicija ugradbenog uređaja se neprestano mijenja kako se razvijaju novi proizvodi s novim izazovima. Prema \textit{Jack G. Ganssle}-ovom i \textit{Michael Barr}-ovom riječniku, \textit{Embedded Systems Dictionary}\cite{ganssle2003embedded}, definicija ugradbenog uređaja je:
\begin{quote}
    ``A combination of computer hardware and software, and perhaps additional mechanical or other parts, designed to perform a dedicated function. In some cases, embedded systems are part of a larger system or product, as in the case of an antilock braking system in a car.''
\end{quote}
% Kombinacija računalong hardvera i softvera i po potrebi dodatnih mehaničkih i/ili drugih dijelova, osmišljenih da izvršavaju odrđenu funkciju. U nekim slučajevima ugradbeni sustavi su dio većeg sistema ili proizvoda kao u slučaju automobilskog ABS sustava. 
Definicija je osmišljena 2003. godine i za to vrijeme vrlo dobro definira ugradbene uređaje, međutim, danas ne obuhvaća mnoge proizvode koji se smatraju ugradbenim uređajima. Ponajviše ova definicija ne obuhvaća uređaje koje nemaju samo jednu dediciranu funkciju, danas ugradbeni uređaji nerijetko imaju i više funkcija. Neke ličnosti u domeni ugradbenih uređaja također navode ovu definiciju međutim pokušavaju je upotpuniti ili preoblikovati. Jedan od utjecajnijih ličnosti u domeni ugradbenih uređaja, \textit{Dan Saks}, daje svoju jednostavniju definiciju\cite{danSaksWritingBetterEmbeddedSoftware}:
\begin{quote}
    ``The job of a computer in an embedded system is to be something other than a general-purpose computer.''
\end{quote}
Ono što pokušava izreći ovom definicijom je da je ugradbeni uređaj bilo koji uređaj za koje se ne bi smatralo da je računalo. Iako manje precizna definicija, bolje služi u razumjevanju o čemu je riječ kada se govori o ugradbenim uređajima. Drugi ljudi, poput tvorca jezika C++, \textit{Bjarne Straustrup}-a, se ne upuštaju u striktno definiranje\cite{bjarneC++ForEmbeddedSystems} ugradbenih uređaja već se više oslanjaju na sličnosti u razvoju softvera među raznim uređajima i priča o razvoju softvera za ugradbene uređaje na osnovi te sličnosti. Kako bi dodatno istaknuli da je definiranje ugradbenih uređaja težak zadatak, jedan od autora prije navedenog riječnika, \textit{Jack. G. Ganssle}, se 2018.\cite{embeddedDotComWhatsEmbedded} godine osvrnuo na danu definiciju i iskazao svoj skepticizam oko nje te tražio čitatelje za sugestije. \\
Za potrebe ovog diplomskog rada odabiremo definiciju bliže \textit{Dan Saks}-u, te definiramo ugradbeni uređaj kao bilo koji uređaj koji nije smatran računalom generične namjene.     
\pagebreak

\section{Što je upravljački program?}
Upravljački programi\engl{Device Drivers} su\cite{linuxDeviceDrivers}:
\begin{quote}
    ``They(device drivers) are distinct "black boxes" that make a particular piece of hardware respond to a well-defined internal programming interface; they hide completely the details of how the device works.''
\end{quote}
Gornja definicija definira značenje upravljačkog programa u kontekstu \textit{Linux} operacijskog sustava. Općenito operacijski sustavi zahtijevaju upravljačke programe za pojedini hardver kako bi ga mogli utilizirati u samom radu sustava. Ono što je možda prešutno u ovoj defniciji je to da sam operacijski sustav definira jedno sučelje za široki spektar različitih uređaja, što je nužno kako bi se olakšala interakcija između operacijskog sustava i uređaja. Ukoliko bi svaki uređaj imao zasebno sučelje operacijski sustavi bi bili vrlo glomazni i bili bi još kompliciraniji za sami razvoj. Međutim, činjenica da svi uređaji implementiraju jedno definirano sučelje je u ovoj definiciji izrečena samo zato što se govori o upravljačkim programima u kontekstu operacijskih sustava. Za potrebe ugradbenih uređaja nije nužno da upravljački programi imaju identično sučelje, štoviše, u većini slučajeva dizaj kakav se koristi za implementaciju upravljačkih programa u domeni operacijskih sustava bi donio nepotrebnu kompleksnost, nedeterminističnost, vremensku i prostornu složenost, sve odlike nepoželjne u domeni ugradbenih uređaja. \\
Svi navedeni nedostatci su često razlog zašto se u razvoju programske podrške za ugradbene uređaje ne koristi tehnologija operacijskih sustava te se sam program izvodi na tzv. "golom metalu"\engl{Bare Metal}, odnsono program se izvodi na procesoru bez dodatnih posrednika poput operacijskih sustava, virtualnih mašina, interpretera i sl. Upravljački programi se svakako mogu gledati kao apstrakcija hardvera i utoliko, kao i što sama definicija govori, moraju biti sposobni donekle sakriti korišteni uređaj. Ovdje se ponovno vidi korištenje abstrakcije kao alata za suzbijanje kompleksnosti, ukoliko ne bi postojao koncept upravljačkih programa, neposredno korištenje uređaja bi unosilo dodatnu kompleksnost u izradu softvera za ugradbeni uređaj. U kontekstu ovog diplomskog rada upravljački programi poštuju gore navedenu definiciju osim što nisu namjenjeni da imaju jedinstveno sučelje jer bi ta činjenica dovela do pesimizacije krajnjeg softvera. Ova pesimizacija je sasvim razumljiva i poželjna u području generičnog računarstva, međutim vrlo je kobna i često se izbjegava u domeni ugradbenih uređaja zbog gore navedenih razloga. 
\pagebreak

\section{Moderni C++?}
\begin{quote}
    ``C++ is a language for defining and using light-weight abstractions. It has significant strengths in areas where hardware must be handled effectively and there are significant complexity to cope with. This includes many resource constrained systems and much foundational and infrastructure code.''
\end{quote}
Gornja definicija\cite{bjarneStroustrupC++} je data od samog tvorca programskog jezika C++, \textit{Bjarne Stroustrup}-a, i odgovara na pitanje "\textit{što je C++?}". Jezik je napravljen kao nasljednik C programskog jezika s kojim je i danas kompatibilan, gotovo svi C programi su validni C++ programi. C++ posuđuje koncepte iz začetnika objektno orjentirane paradigme, programski jezik Simula, te odlučuje koncepte poput razreda, sučelja, nasljeđivanja i sl. ponuditi korisnicima kako bi kreirali abstrakcije na korisničkoj razini koji su u mnogočemu ekvipotentni apstrakcijama ugrađenim direktno u sam jezik. Ovo je vrlo moćan koncept gdje se korisniku omogućuje da efektivno može poširiti jezik sa vlastitim apstrakcijama bez ulaženja u internu implementaciju i standardizaciju jezika. Doduše nije C++ jedini jezik koji omogućava kreiranje apstrakcija na korisničkoj razini, međutim interna filozofija jezika C++ ga odvaja od drugih jezika. Glavna filozofija jezika C++, koja na neki način vodi daljnji razvoj jezika, može se ukratko izreći kao\cite{theDesignAndEvolutionOfC++}:
\begin{quote}
    ``What you don't use, you don't pay for.''
\end{quote}
Gornji citat je ono što razlikuje C++ od toliko drugih jezika, ono što se pokušava izreći se još zove i \textbf{Zero-Overhead} princip, točnije govori se o tome kako je jezik koncipiran na način da korisnik može napisati program tako da "ne plaća" ništa drugo osim onoga što mu je potrebno za implementaciju softvera. Ovo se čini možda suvišno za izreći ali u praksi se mnogo puta ispostavlja da su određena svojstva jezika povezana i ukoliko korisnik želi koristiti jedno svojstvo nužno povlači i drugo o kojem ovisi čak iako u trenutnom kontekstu nema logičke ovisnosti, već samo dizajnerske ovisnosti. Ono što se pokušava reći da se dizajneri mnogih jezika odlučuju dizajnirati jezična svojstva na način da određena svojstva jezika nisu međusobno isključiva čak iako logički to jesu. Štoviše, takav dizajn često dovodi do vremenske i prostorne složenosti na korist smanjenja korisničke kompleksnosti. C++ kao jezik koji se reklamira kao moguća opcija u razvoju operacijskih sustava, domeni ugradbenih uređaja, autoindustriji, itd., nije dizajniran tako da "žrtvuje" vremensku i prostornu složenost za smanjenje kompleksnosti. To naravno ne znači kako jezik ne nudi nikakve mehanizme za suzbijanje kompleksnosti, nego da pesimiziranje vremenske i prostorne složenosti nije prihvatljivo kako bi se smanjila kompleksnost. \\

Dakako, ništa od predhodno navedenog ne odgovara na pitanje "\textit{što je moderni C++?}". Moderni C++ je često vidljiva sintagma u C++ zajednici i šire koja implicira da postoji modernija inačica jezika C++, to je istina, međutim to ne znači da je to potpuno drugi jezik. Sam jezik C++ nastao je 1985. godine, a 1998. je prvi put standardiziran kao \textit{ISO}\footnote{International Organization for Standardization} standard, iz toga je vidljivo da sam jezik ne asocira na riječ "moderan" jer potječe iz 80-tih godina prošlog stojeća. Međutim, recentniji standardi jezika(2011. godina nadalje) su revitalizirali jezik sa novim, sigurnijim i sve u svemu boljim svojstvima koje se uvelike oslanjaju na moderne tehnike statičke analize i povijesno dobre prakse. Ugrubo gledajući, sintagma "moderan C++" govori o jeziku C++ nakon standarda uvedenog 2011. godine. Dakako standardizacija jezika C++ nije stala i još uvijek je procesu izgradnje međutim C++11 standard se generalno uzima kao početak "modernog C++"-a. Osim C++11 standarda, postoje C++14, C++17 i najnoviji C++20 standard. Za potrebe ovog rada koriste se jezična svojstva iz svih navedenih standarda međutim ne spominje se eksplicitno za svako svojstvo iz kojeg standarda potječe jer je ta činjenica suvišna za kontekst ovog rada.
