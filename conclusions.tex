\chapter{Zaključak}
Ukoliko pogledamo \hyperref[table:results]{tablicu} rezultata vidljivo je kako je veličina programa u određenom modu prevođenja izgrađena uz pomoć programskog jezika C++ uvijek proporcionalno manja s obzirom na tehnologiju programskog jezika C. Ovi rezultati ne govore o tome da je to istina za svaki slučaj međutim pobija teze koje govore da su programi izgrađeni uz pomoć jezika C++ uvijek veći od funkcijski ekvivalentnih C programa. Ovdje se vidi snaga ekspresije modernog programskog jezika koja omogućava provodiocu da elminira određene dijelove koda te omogućava ekstenzivnije i agresivnije optimizacije. S druge strane ako se pogledaju prosječna vremena izvođenja vidljivo je kako programski jezik C još uvijek prednjači programskom jeziku C++ u \textit{Debug} modu prevođenja. Ovo je za očekivati jer programski jezik C++ je nešto kompleksniji od programskog jezika C i time gubi na vremenu izvođenja bez uključivanja optimizatora na višim razinama optimizacije. Kada se osbosobi optimizator u \textit{Release} modu prevođenja može se vidjeti kako su prosječna vremena izvođenja identična za slučajeve kada se upravljački program koristi u modu s iznimkama. Upravljački program u modu s radnim čekanjem uvijek biva najsporija opcija što se vrlo vjerojatno može prepisati samom dizajnu takvog moda, a ne samoj tehnologiji izvedbe. Radno čekanje se opčenito izbjegava jer troši procesorske resurse, a kao što je ovdje i pokazano, ne daje zadovoljavajuće rezultate. Vjerojatno su se zato i dizajneri unutar \textit{Nordic Semiconductors} kompanije i odlučili kako neće podržati mod radnog čekanja unutar upravljačkog programa za generator slučajnih brojeva, međutim tom odlukom je implicitno rečeno da mikrokontroler mora koristiti mehanizam iznimki koji ponekad nije dostupan ili nedopušten. Na stranu sa implementacijom upravljačkog programa u modu s radnim čekanjem, oba upravljačka programa u modu s inznikama daju jednako vrijeme izvođenja, odnosno mala greška se ovdje pripisuje nedeterminističnosti uređaja za generiranje slučajnih brojeva i zaključujemo kako su vremena izvođenja identična. Ovime se pokazuje kako se korištenjem pomno odabranih modernih tehnologija ne žrtvuje vrijeme izvođenja i kako korisnik može imati potpunu moć da time što će na kraju prevodilac emitirati u krajnji izvršni program. Ono što još valja reči kako je kvaliteta i ekspresivnost koda puno bolja u modernih tehnologija, ovo svojstvo nije kvantificirano, međutim čitatelja se snažno potiče da pregleda izvorne kodove programa i procijeni sam. Ono što valja reći je to da je istina kako moderne tehnologije, naručito programski jezik C++, jesu kompliciranije u odnosu na tehnologije poput programskog jezika C, međutim upravo zbog te kompleksnosti daju mogućnost ekspresije koju čak i prevodilac može razumjeti i na osnovu tih informacija generirati bolji, sigurniji i manji program. Svojstvo ekspresivnosti kroz koncept abstrakcije je svojstvo koje moderne tehnologije nude u odnosu na stare i to će se u budućnosti samo perpeturati kako bi se stare tehnologije istisnule iz domena koje bi stvarno trebale koristiti nešto modernije. Na kraju treba reći kako će programski jezik C uvijek imati mjesto u budučnosti računarstva međutim, kako to obično biva, inžinjeri moraju osvjestiti kako programski jezik C nije uvijek najbolji alat za sve probleme, pogotovo u domeni ugradbenih uređaja, i kako postoje bolji, moderniji alati, poput programskog jezika C++. 